!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASSERT	.\common.h	77;"	d
ASSERT2	.\common.h	59;"	d
BLOCK_INCLUDED	.\block.h	2;"	d
BLOCK_MASK	.\block.h	9;"	d
BLOCK_SIZE	.\block.h	8;"	d
BLOCK_SIZE_BITS	.\block.h	7;"	d
COMMON_H	.\common.h	8;"	d
DATA_BLOCK_NUMBER	.\fs.h	46;"	d
DIRECTORY	.\common.h	104;"	d
DIRECT_BLOCK	.\fs.h	68;"	d
DIR_ENTRY_PADDING	.\fs.h	84;"	d
DIR_ENTRY_PER_BLOCK	.\fs.h	86;"	d
ERROR_MSG	.\fs.c	11;"	d	file:
ERROR_MSG	.\fs.c	13;"	d	file:
FALSE	.\common.h	/^	FALSE, TRUE$/;"	e	enum:__anon2
FILE_TYPE	.\common.h	105;"	d
FREE_INODE	.\common.h	103;"	d
FS_INCLUDED	.\fs.h	5;"	d
FS_O_RDONLY	.\common.h	107;"	d
FS_O_RDWR	.\common.h	109;"	d
FS_O_WRONLY	.\common.h	108;"	d
FS_SIZE	.\fs.h	8;"	d
HALT	.\common.h	80;"	d
INODE_BLOCK_NUMBER	.\fs.h	45;"	d
INODE_PADDING	.\fs.h	69;"	d
INODE_PER_BLOCK	.\fs.h	72;"	d
MAX_FILE_COUNT	.\fs.h	32;"	d
MAX_FILE_NAME	.\fs.h	24;"	d
MAX_FILE_ONE_DIR	.\fs.h	40;"	d
MAX_FILE_SIZE	.\fs.h	35;"	d
MAX_FILE_SIZE	.\fs.h	37;"	d
MAX_IMAGE_SIZE	.\block.h	4;"	d
MAX_OPEN_FILE_NUM	.\fs.h	101;"	d
MAX_PATH_NAME	.\fs.h	25;"	d
MSG_SIZE	.\common.h	140;"	d
MSG_T_HEADER_SIZE	.\common.h	138;"	d
MY_MAGIC	.\fs.h	51;"	d
NULL	.\common.h	11;"	d
ROOT_DIR_ID	.\fs.h	83;"	d
SB_PADDING	.\fs.h	50;"	d
SCREEN_ADDR	.\common.h	18;"	d
SECTOR_SIZE	.\common.h	15;"	d
START_SECTOR	.\block.c	7;"	d	file:
SUPER_BLOCK	.\fs.h	43;"	d
SUPER_BLOCK_BACKUP	.\fs.h	44;"	d
SYSCALL_CD	.\common.h	/^	SYSCALL_CD,$/;"	e	enum:__anon1
SYSCALL_CLOSE	.\common.h	/^	SYSCALL_CLOSE,   \/* 15 *\/$/;"	e	enum:__anon1
SYSCALL_COUNT	.\common.h	/^	SYSCALL_COUNT$/;"	e	enum:__anon1
SYSCALL_CPUSPEED	.\common.h	/^	SYSCALL_CPUSPEED,    \/* 5 *\/$/;"	e	enum:__anon1
SYSCALL_EXIT	.\common.h	/^	SYSCALL_EXIT,$/;"	e	enum:__anon1
SYSCALL_FSCK	.\common.h	/^	SYSCALL_FSCK,$/;"	e	enum:__anon1
SYSCALL_GETCHAR	.\common.h	/^	SYSCALL_GETCHAR,$/;"	e	enum:__anon1
SYSCALL_GETPID	.\common.h	/^	SYSCALL_GETPID,$/;"	e	enum:__anon1
SYSCALL_GETPRIORITY	.\common.h	/^	SYSCALL_GETPRIORITY,$/;"	e	enum:__anon1
SYSCALL_LINK	.\common.h	/^	SYSCALL_LINK,$/;"	e	enum:__anon1
SYSCALL_LOADPROC	.\common.h	/^	SYSCALL_LOADPROC,$/;"	e	enum:__anon1
SYSCALL_LSEEK	.\common.h	/^	SYSCALL_LSEEK,$/;"	e	enum:__anon1
SYSCALL_MBOX_CLOSE	.\common.h	/^	SYSCALL_MBOX_CLOSE,$/;"	e	enum:__anon1
SYSCALL_MBOX_OPEN	.\common.h	/^	SYSCALL_MBOX_OPEN,$/;"	e	enum:__anon1
SYSCALL_MBOX_RECV	.\common.h	/^	SYSCALL_MBOX_RECV,$/;"	e	enum:__anon1
SYSCALL_MBOX_SEND	.\common.h	/^	SYSCALL_MBOX_SEND,   \/* 10 *\/$/;"	e	enum:__anon1
SYSCALL_MBOX_STAT	.\common.h	/^	SYSCALL_MBOX_STAT,$/;"	e	enum:__anon1
SYSCALL_MKDIR	.\common.h	/^	SYSCALL_MKDIR,$/;"	e	enum:__anon1
SYSCALL_MKFS	.\common.h	/^	SYSCALL_MKFS,$/;"	e	enum:__anon1
SYSCALL_OPEN	.\common.h	/^	SYSCALL_OPEN,$/;"	e	enum:__anon1
SYSCALL_READ	.\common.h	/^	SYSCALL_READ, $/;"	e	enum:__anon1
SYSCALL_READDIR	.\common.h	/^	SYSCALL_READDIR,  \/* 25 *\/$/;"	e	enum:__anon1
SYSCALL_RMDIR	.\common.h	/^	SYSCALL_RMDIR,   \/* 20 *\/$/;"	e	enum:__anon1
SYSCALL_SETPRIORITY	.\common.h	/^	SYSCALL_SETPRIORITY,$/;"	e	enum:__anon1
SYSCALL_STAT	.\common.h	/^	SYSCALL_STAT,$/;"	e	enum:__anon1
SYSCALL_UNLINK	.\common.h	/^	SYSCALL_UNLINK,$/;"	e	enum:__anon1
SYSCALL_WRITE	.\common.h	/^	SYSCALL_WRITE,$/;"	e	enum:__anon1
SYSCALL_WRITE_SERIAL	.\common.h	/^	SYSCALL_WRITE_SERIAL,$/;"	e	enum:__anon1
SYSCALL_YIELD	.\common.h	/^	SYSCALL_YIELD,       \/* 0 *\/$/;"	e	enum:__anon1
TRUE	.\common.h	/^	FALSE, TRUE$/;"	e	enum:__anon2
UTIL_INCLUDED	.\util.h	2;"	d
_padding	.\fs.h	/^	char _padding[DIR_ENTRY_PADDING];$/;"	m	struct:__anon7
_padding	.\fs.h	/^	char _padding[SB_PADDING];$/;"	m	struct:__anon5
atoi	.\util.c	/^atoi( const char *s) {$/;"	f
bcopy	.\util.c	/^void bcopy(unsigned char *source, unsigned char *destin, int size)$/;"	f
block_init	.\block.c	/^void block_init( void) {$/;"	f
block_init	.\blockFake.c	/^block_init( void) {$/;"	f
block_read	.\block.c	/^void block_read( int block, char *mem) {$/;"	f
block_read	.\blockFake.c	/^block_read( int block, char *mem) {$/;"	f
block_scratch	.\fs.c	/^static char block_scratch[BLOCK_SIZE];\/\/inode read\/write use this$/;"	v	file:
block_write	.\block.c	/^void block_write( int block, char *mem) {$/;"	f
block_write	.\blockFake.c	/^block_write( int block, char *mem) {$/;"	f
blocks	.\fs.h	/^	uint16_t blocks[DIRECT_BLOCK+1];$/;"	m	struct:__anon6
body	.\common.h	/^	char body[0];	\/\/	Pointer to start of message contents$/;"	m	struct:__anon4
bool_t	.\common.h	/^} bool_t;$/;"	t	typeref:enum:__anon2
bzero	.\util.c	/^void bzero(char *area, int size)$/;"	f
bzero_block	.\block.c	/^void bzero_block( char *block) {$/;"	f
bzero_block	.\blockFake.c	/^bzero_block( char *block) {$/;"	f
clear_screen	.\util.c	/^void clear_screen(int minx, int miny, int maxx, int maxy)$/;"	f
cursor	.\fs.h	/^	uint32_t cursor;\/\/in bytes$/;"	m	struct:__anon8
dblock_alloc	.\fs.c	/^static int dblock_alloc(void)$/;"	f	file:
dblock_bitmap_block_scratch	.\fs.c	/^static char dblock_bitmap_block_scratch[BLOCK_SIZE];$/;"	v	file:
dblock_bitmap_last	.\fs.c	/^static uint16_t dblock_bitmap_last=0;\/\/start from 0$/;"	v	file:
dblock_bitmap_place	.\fs.h	/^	uint16_t dblock_bitmap_place;$/;"	m	struct:__anon5
dblock_count	.\fs.h	/^	uint16_t dblock_count;$/;"	m	struct:__anon5
dblock_free	.\fs.c	/^static void dblock_free(int index)$/;"	f	file:
dblock_read	.\fs.c	/^static void dblock_read(int index,char* block_buff)$/;"	f	file:
dblock_start	.\fs.h	/^	uint16_t dblock_start;$/;"	m	struct:__anon5
dblock_write	.\fs.c	/^static void dblock_write(int index,char* block_buff)$/;"	f	file:
delay	.\util.c	/^void delay(int n)$/;"	f
dir_entry	.\fs.h	/^}dir_entry;$/;"	t	typeref:struct:__anon7
directory_t	.\common.h	/^struct directory_t {$/;"	s
dprint	.\util.c	/^void dprint (char *str)$/;"	f
fd	.\blockFake.c	/^static FILE *fd;$/;"	v	file:
fd_table	.\fs.c	/^static file_des fd_table[MAX_OPEN_FILE_NUM];$/;"	v	file:
fileStat	.\common.h	/^} fileStat;$/;"	t	typeref:struct:__anon3
file_des	.\fs.h	/^}file_des;$/;"	t	typeref:struct:__anon8
file_name	.\fs.h	/^	char file_name[MAX_FILE_NAME+1];$/;"	m	struct:__anon7
file_sys_size	.\fs.h	/^	uint16_t file_sys_size;$/;"	m	struct:__anon5
find_next_free	.\fs.c	/^static int find_next_free(int i_d)\/\/must alloc(write 1) after call this function$/;"	f	file:
fs_cd	.\fs.c	/^int fs_cd( char *dirName) {$/;"	f
fs_close	.\fs.c	/^int fs_close( int fd) {$/;"	f
fs_init	.\fs.c	/^void fs_init( void) {$/;"	f
fs_link	.\fs.c	/^int fs_link( char *old_fileName, char *new_fileName) {$/;"	f
fs_lseek	.\fs.c	/^int fs_lseek( int fd, int offset) {$/;"	f
fs_mkdir	.\fs.c	/^int fs_mkdir( char *fileName) {$/;"	f
fs_mkfs	.\fs.c	/^int fs_mkfs( void) {$/;"	f
fs_open	.\fs.c	/^int fs_open( char *fileName, int flags) {$/;"	f
fs_read	.\fs.c	/^int fs_read( int fd, char *buf, int count) {$/;"	f
fs_rmdir	.\fs.c	/^int fs_rmdir( char *fileName) {$/;"	f
fs_stat	.\fs.c	/^int fs_stat( char *fileName, fileStat *buf) {$/;"	f
fs_unlink	.\fs.c	/^int fs_unlink( char *fileName) {$/;"	f
fs_write	.\fs.c	/^int fs_write( int fd, char *buf, int count) {$/;"	f
get_timer	.\util.c	/^uint64_t	get_timer(void) {$/;"	f
inb	.\util.c	/^uchar_t inb(int port)$/;"	f
inode	.\fs.h	/^}inode;$/;"	t	typeref:struct:__anon6
inodeNo	.\common.h	/^    int inodeNo;        \/* the file i-node number *\/$/;"	m	struct:__anon3
inode_alloc	.\fs.c	/^static int inode_alloc(void)$/;"	f	file:
inode_bitmap_block_scratch	.\fs.c	/^static char inode_bitmap_block_scratch[BLOCK_SIZE];$/;"	v	file:
inode_bitmap_last	.\fs.c	/^static uint16_t inode_bitmap_last=0;\/\/start from 0$/;"	v	file:
inode_bitmap_place	.\fs.h	/^	uint16_t inode_bitmap_place;$/;"	m	struct:__anon5
inode_count	.\fs.h	/^	uint16_t inode_count;$/;"	m	struct:__anon5
inode_create	.\fs.c	/^static void inode_create(int type)\/\/ 0 for dir 1 for file$/;"	f	file:
inode_free	.\fs.c	/^static void inode_free(int index)$/;"	f	file:
inode_id	.\fs.h	/^	uint16_t inode_id;$/;"	m	struct:__anon7
inode_id	.\fs.h	/^	uint16_t inode_id;$/;"	m	struct:__anon8
inode_init	.\fs.c	/^static void inode_init(inode *p,int type) \/\/ 0 for dir , 1 for file$/;"	f	file:
inode_read	.\fs.c	/^static void inode_read(int index,char* inode_buff)$/;"	f	file:
inode_start	.\fs.h	/^	uint16_t inode_start;$/;"	m	struct:__anon5
inode_write	.\fs.c	/^static void inode_write(int index,char* inode_buff)$/;"	f	file:
int16_t	.\common.h	/^typedef short int int16_t;$/;"	t
int32_t	.\common.h	/^typedef int int32_t;$/;"	t
int64_t	.\common.h	/^typedef long long int int64_t;$/;"	t
int8_t	.\common.h	/^typedef signed char int8_t;$/;"	t
iodelay	.\util.c	/^void iodelay(void)$/;"	f
is_using	.\fs.h	/^	bool_t is_using;$/;"	m	struct:__anon8
itoa	.\util.c	/^itoa( int n, char *s) {$/;"	f
itohex	.\util.c	/^void itohex(unsigned int n, char *s)$/;"	f
link_count	.\fs.h	/^	uint16_t link_count;$/;"	m	struct:__anon6
links	.\common.h	/^    char links;         \/* number of links to the i-node *\/$/;"	m	struct:__anon3
location	.\common.h	/^	int location;	\/\/	Sector number$/;"	m	struct:directory_t
magic_num	.\fs.h	/^	uint32_t magic_num;$/;"	m	struct:__anon5
mode	.\fs.h	/^	uint16_t mode;\/\/(FS_O_RDONLY, FS_O_WRONLY, FS_ORDWR)$/;"	m	struct:__anon8
ms_delay	.\util.c	/^void		ms_delay(uint32_t msecs) {$/;"	f
ms_to_cycles	.\util.c	/^static uint64_t ms_to_cycles(uint32_t msecs) {$/;"	f	file:
msg_t	.\common.h	/^} __attribute__ ((packed)) msg_t;$/;"	t	typeref:struct:__anon4
my_sb	.\fs.c	/^static super_b * my_sb;$/;"	v	file:
numBlocks	.\common.h	/^    int numBlocks;      \/* number of blocks used by the file *\/$/;"	m	struct:__anon3
outb	.\util.c	/^void outb(int port, uchar_t data)$/;"	f
peek_screen	.\util.c	/^int peek_screen(int x, int y)$/;"	f
print_char	.\util.c	/^void print_char(int line, int col, char c)$/;"	f
print_hex	.\util.c	/^void print_hex(int line, int col, unsigned int num)$/;"	f
print_int	.\util.c	/^void print_int(int line, int col, int num)$/;"	f
print_str	.\util.c	/^void print_str(int line, int col, char *str)$/;"	f
pwd	.\fs.c	/^static uint16_t pwd;$/;"	v	file:
read_bitmap_block	.\fs.c	/^static int read_bitmap_block(int i_d,int index)\/\/ 0 for inode bitmap,1 for data bitmap$/;"	f	file:
reverse	.\util.c	/^void reverse(char *s)$/;"	f
same_string	.\util.c	/^int same_string(char *s1, char *s2)$/;"	f
sb_write	.\fs.c	/^static void sb_write()$/;"	f	file:
screen	.\util.c	/^static short *screen = SCREEN_ADDR;$/;"	v	file:
scroll	.\util.c	/^void scroll(int minx, int miny, int maxx, int maxy)$/;"	f
size	.\common.h	/^	int size;		\/\/	Size in number of sectors$/;"	m	struct:directory_t
size	.\common.h	/^	int size;		\/\/	Size of message contents in bytes$/;"	m	struct:__anon4
size	.\common.h	/^    int size;           \/* file size in bytes *\/$/;"	m	struct:__anon3
size	.\fs.h	/^	uint32_t size;\/\/in bytes$/;"	m	struct:__anon6
strlen	.\util.c	/^int strlen(const char *s)$/;"	f
super_b	.\fs.h	/^}super_b;$/;"	t	typeref:struct:__anon5
super_block_scratch	.\fs.c	/^static char super_block_scratch[BLOCK_SIZE];$/;"	v	file:
type	.\common.h	/^    short type;         \/* the file i-node type, DIRECTORY, FILE_TYPE (there's another value FREE_INODE which never appears here *\/$/;"	m	struct:__anon3
type	.\fs.h	/^	uint16_t type;\/\/0 for dir, 1 for file$/;"	m	struct:__anon6
uchar_t	.\common.h	/^typedef unsigned char uchar_t;$/;"	t
uint16_t	.\common.h	/^typedef unsigned short int uint16_t;$/;"	t
uint32_t	.\common.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	.\common.h	/^typedef unsigned long long int uint64_t;$/;"	t
uint8_t	.\common.h	/^typedef unsigned char uint8_t;$/;"	t
uint_t	.\common.h	/^typedef unsigned int uint_t;$/;"	t
ulong_t	.\common.h	/^typedef unsigned long ulong_t;$/;"	t
write_bitmap_block	.\fs.c	/^static void write_bitmap_block(int i_d,int index,int val) \/\/ 0 for inode bitmap,1 for data bitmap$/;"	f	file:
